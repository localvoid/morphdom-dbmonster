{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","web/js/main.js","node_modules/morphdom/lib/index.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"main.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\n\nvar morphdom = require('morphdom');\nvar I = 0;\nvar N = 100;\n\nfunction Query(elapsed, waiting, query) {\n  this.elapsed = elapsed;\n  this.waiting = waiting;\n  this.query = query;\n}\n\nQuery.rand = function() {\n  var elapsed = Math.random() * 15;\n  var waiting = Math.random() < 0.5;\n  var query = 'SELECT blah FROM something';\n\n  if (Math.random() < 0.2) {\n    query = '<IDLE> in transaction';\n  }\n\n  if (Math.random() < 0.1) {\n    query = 'vacuum';\n  }\n\n  return new Query(elapsed, waiting, query);\n};\n\nvar _nextId = 0;\nfunction Database(name) {\n  this.id = _nextId++;\n  this.name = name;\n  this.queries = null;\n\n  this.update();\n}\n\nDatabase.prototype.update = function() {\n  var queries = [];\n\n  var r = Math.floor((Math.random() * 10) + 1);\n  for (var j = 0; j < r; j++) {\n    queries.push(Query.rand());\n  }\n\n  this.queries = queries;\n};\n\nDatabase.prototype.getTopFiveQueries = function() {\n  var qs = this.queries.slice();\n  qs.sort(function(a, b) {\n    return a.elapsed - b.elapsed;\n  });\n  qs = qs.slice(0, 5);\n  while (qs.length < 5) {\n    qs.push(new Query(0.0, false, ''));\n  }\n  return qs;\n};\n\nfunction formatElapsed(v) {\n  if (!v) return '';\n\n  var str = parseFloat(v).toFixed(2);\n\n  if (v > 60) {\n    var minutes = Math.floor(v / 60);\n    var comps = (v % 60).toFixed(2).split('.');\n    var seconds = comps[0];\n    var ms = comps[1];\n    str = minutes + \":\" + seconds + \".\" + ms;\n  }\n\n  return str;\n}\n\nfunction labelClass(count) {\n  if (count >= 20) {\n    return 'label label-important';\n  } else if (count >= 10) {\n    return 'label label-warning';\n  }\n  return 'label label-success';\n}\n\nfunction elapsedClass(t) {\n  if (t >= 10.0) {\n    return 'Query elapsed warn_long';\n  } else if (t >= 1.0) {\n    return 'Query elapsed warn';\n  }\n  return 'Query elapsed short';\n}\n\nfunction render(dbs) {\n  var table = document.createElement('table');\n  table.className = 'table table-striped table-latest-data';\n\n  var tbody = document.createElement('tbody');\n  table.appendChild(tbody);\n\n  for (var i = 0; i < dbs.length; i++) {\n    var db = dbs[i];\n    var topFiveQueries = db.getTopFiveQueries();\n    var count = db.queries.length;\n\n    var row = document.createElement('tr');\n    row.id = 'row_' + db.id;\n    tbody.appendChild(row);\n\n    var nameCol = document.createElement('td');\n    nameCol.className = 'dbname';\n    nameCol.textContent = db.name;\n    row.appendChild(nameCol);\n\n    var countCol = document.createElement('td');\n    countCol.className = 'query-count';\n    row.appendChild(countCol);\n\n    var countColSpan = document.createElement('span');\n    countColSpan.className = labelClass(count);\n    countColSpan.textContent = count;\n    countCol.appendChild(countColSpan);\n\n    for (var j = 0; j < 5; j++) {\n      var q = topFiveQueries[j];\n      var elapsed = q.elapsed;\n\n      var col = document.createElement('td');\n      col.className = elapsedClass(elapsed);\n      row.appendChild(col);\n\n      var txt = document.createTextNode(formatElapsed(elapsed));\n      col.appendChild(txt);\n\n      var popover = document.createElement('div');\n      popover.className = 'popover left';\n      col.appendChild(popover);\n\n      var popoverContent = document.createElement('div');\n      popoverContent.className = 'popover-content';\n      popover.appendChild(popoverContent);\n\n      var popoverTxt = document.createTextNode(q.query);\n      popoverContent.appendChild(popoverTxt);\n\n      var popoverArrow = document.createElement('div');\n      popoverArrow.className = 'arrow';\n      popover.appendChild(popoverArrow);\n    }\n  }\n\n  return table;\n}\n\ndocument.addEventListener('DOMContentLoaded', function() {\n  var dbs = [];\n  for (var i = 0; i < N; i++) {\n    dbs.push(new Database('cluster' + i));\n    dbs.push(new Database('cluster' + i + 'slave'));\n  }\n\n  var container = document.getElementById('app');\n  var root = render(dbs);\n  container.appendChild(root);\n\n  function update() {\n    for (var i = 0; i < dbs.length; i++) {\n      dbs[i].update();\n    }\n    morphdom(root, render(dbs));\n    Monitoring.renderRate.ping();\n    setTimeout(update, I);\n  }\n  update();\n});\n","var specialElHandlers = {\n    /**\n     * Needed for IE. Apparently IE doesn't think\n     * that \"selected\" is an attribute when reading\n     * over the attributes using selectEl.attributes\n     */\n    OPTION: function(fromEl, toEl) {\n        if ((fromEl.selected = toEl.selected)) {\n            fromEl.setAttribute('selected', '');\n        } else {\n            fromEl.removeAttribute('selected', '');\n        }\n    },\n    /**\n     * The \"value\" attribute is special for the <input> element\n     * since it sets the initial value. Changing the \"value\"\n     * attribute without changing the \"value\" property will have\n     * no effect since it is only used to the set the initial value.\n     * Similar for the \"checked\" attribute.\n     */\n    INPUT: function(fromEl, toEl) {\n        fromEl.checked = toEl.checked;\n        fromEl.value = toEl.value;\n\n        if (!toEl.hasAttribute('checked')) {\n            fromEl.removeAttribute('checked');\n        }\n\n        if (!toEl.hasAttribute('value')) {\n            fromEl.removeAttribute('value');\n        }\n    }\n};\n\nfunction noop() {}\n\n/**\n * Loop over all of the attributes on the target node and make sure the\n * original DOM node has the same attributes. If an attribute\n * found on the original node is not on the new node then remove it from\n * the original node\n * @param  {HTMLElement} fromNode\n * @param  {HTMLElement} toNode\n */\nfunction morphAttrs(fromNode, toNode) {\n    var attrs = toNode.attributes;\n    var i;\n    var attr;\n    var attrName;\n    var attrValue;\n    var foundAttrs = {};\n\n    for (i=attrs.length-1; i>=0; i--) {\n        attr = attrs[i];\n        if (attr.specified !== false) {\n            attrName = attr.name;\n            attrValue = attr.value;\n            foundAttrs[attrName] = true;\n\n            if (fromNode.getAttribute(attrName) !== attrValue) {\n                fromNode.setAttribute(attrName, attrValue);\n            }\n        }\n    }\n\n    // Delete any extra attributes found on the original DOM element that weren't\n    // found on the target element.\n    attrs = fromNode.attributes;\n\n    for (i=attrs.length-1; i>=0; i--) {\n        attr = attrs[i];\n        if (attr.specified !== false) {\n            attrName = attr.name;\n            if (!foundAttrs.hasOwnProperty(attrName)) {\n                fromNode.removeAttribute(attrName);\n            }\n        }\n    }\n}\n\n/**\n * Copies the children of one DOM element to another DOM element\n */\nfunction moveChildren(from, to) {\n    var curChild = from.firstChild;\n    while(curChild) {\n        var nextChild = curChild.nextSibling;\n        to.appendChild(curChild);\n        curChild = nextChild;\n    }\n    return to;\n}\n\nfunction morphdom(fromNode, toNode, options) {\n    if (!options) {\n        options = {};\n    }\n\n    if (typeof toNode === 'string') {\n        var newBodyEl = document.createElement('body');\n        newBodyEl.innerHTML = toNode;\n        toNode = newBodyEl.childNodes[0];\n    }\n\n    var savedEls = {}; // Used to save off DOM elements with IDs\n    var unmatchedEls = {};\n    var onNodeDiscarded = options.onNodeDiscarded || noop;\n    var onBeforeMorphEl = options.onBeforeMorphEl || noop;\n    var onBeforeMorphElChildren = options.onBeforeMorphElChildren || noop;\n\n    function removeNodeHelper(node, nestedInSavedEl) {\n        var id = node.id;\n        // If the node has an ID then save it off since we will want\n        // to reuse it in case the target DOM tree has a DOM element\n        // with the same ID\n        if (id) {\n            savedEls[id] = node;\n        } else if (!nestedInSavedEl) {\n            // If we are not nested in a saved element then we know that this node has been\n            // completely discarded and will not exist in the final DOM.\n            onNodeDiscarded(node);\n        }\n\n        if (node.nodeType === 1) {\n            var curChild = node.firstChild;\n            while(curChild) {\n                removeNodeHelper(curChild, nestedInSavedEl || id);\n                curChild = curChild.nextSibling;\n            }\n        }\n    }\n\n    function walkDiscardedChildNodes(node) {\n        if (node.nodeType === 1) {\n            var curChild = node.firstChild;\n            while(curChild) {\n\n\n                if (!curChild.id) {\n                    // We only want to handle nodes that don't have an ID to avoid double\n                    // walking the same saved element.\n\n                    onNodeDiscarded(curChild);\n\n                    // Walk recursively\n                    walkDiscardedChildNodes(curChild);\n                }\n\n                curChild = curChild.nextSibling;\n            }\n        }\n    }\n\n    function removeNode(node, parentNode, alreadyVisited) {\n        parentNode.removeChild(node);\n\n        if (alreadyVisited) {\n            if (!node.id) {\n                onNodeDiscarded(node);\n                walkDiscardedChildNodes(node);\n            }\n        } else {\n            removeNodeHelper(node);\n        }\n    }\n\n    function morphEl(fromNode, toNode, alreadyVisited) {\n        if (toNode.id) {\n            // If an element with an ID is being morphed then it is will be in the final\n            // DOM so clear it out of the saved elements collection\n            delete savedEls[toNode.id];\n        }\n\n        if (onBeforeMorphEl(fromNode, toNode) === false) {\n            return;\n        }\n\n        morphAttrs(fromNode, toNode);\n\n        if (onBeforeMorphElChildren(fromNode, toNode) === false) {\n            return;\n        }\n\n        var curToNodeChild = toNode.firstChild;\n        var curFromNodeChild = fromNode.firstChild;\n        var curToNodeId;\n\n        var fromNextSibling;\n        var toNextSibling;\n        var savedEl;\n        var unmatchedEl;\n\n        outer: while(curToNodeChild) {\n            toNextSibling = curToNodeChild.nextSibling;\n            curToNodeId = curToNodeChild.id;\n\n            while(curFromNodeChild) {\n                var curFromNodeId = curFromNodeChild.id;\n                fromNextSibling = curFromNodeChild.nextSibling;\n\n                if (!alreadyVisited) {\n                    if (curFromNodeId && (unmatchedEl = unmatchedEls[curFromNodeId])) {\n                        unmatchedEl.parentNode.replaceChild(curFromNodeChild, unmatchedEl);\n                        morphEl(curFromNodeChild, unmatchedEl, alreadyVisited);\n                        curFromNodeChild = fromNextSibling;\n                        continue;\n                    }\n                }\n\n                var curFromNodeType = curFromNodeChild.nodeType;\n\n                if (curFromNodeType === curToNodeChild.nodeType) {\n                    var isCompatible = false;\n\n                    if (curFromNodeType === 1) { // Both nodes being compared are Element nodes\n                        if (curFromNodeChild.tagName === curToNodeChild.tagName) {\n                            // We have compatible DOM elements\n                            if (curFromNodeId || curToNodeId) {\n                                // If either DOM element has an ID then we handle\n                                // those differently since we want to match up\n                                // by ID\n                                if (curToNodeId === curFromNodeId) {\n                                    isCompatible = true;\n                                }\n                            } else {\n                                isCompatible = true;\n                            }\n                        }\n\n                        if (isCompatible) {\n                            // We found compatible DOM elements so transform the current \"from\" node\n                            // to match the current target DOM node.\n                            morphEl(curFromNodeChild, curToNodeChild, alreadyVisited);\n                        }\n                    } else if (curFromNodeType === 3) { // Both nodes being compared are Text nodes\n                        isCompatible = true;\n                        // Simply update nodeValue on the original node to change the text value\n                        curFromNodeChild.nodeValue = curToNodeChild.nodeValue;\n                    }\n\n                    if (isCompatible) {\n                        curToNodeChild = toNextSibling;\n                        curFromNodeChild = fromNextSibling;\n                        continue outer;\n                    }\n                }\n\n                // No compatible match so remove the old node from the DOM and continue trying\n                // to find a match in the original DOM\n                removeNode(curFromNodeChild, fromNode, alreadyVisited);\n                curFromNodeChild = fromNextSibling;\n            }\n\n            if (curToNodeId) {\n                if ((savedEl = savedEls[curToNodeId])) {\n                    morphEl(savedEl, curToNodeChild, true);\n                    curToNodeChild = savedEl; // We want to append the saved element instead\n                } else {\n                    // The current DOM element in the target tree has an ID\n                    // but we did not find a match in any of the corresponding\n                    // siblings. We just put the target element in the old DOM tree\n                    // but if we later find an element in the old DOM tree that has\n                    // a matching ID then we will replace the target element\n                    // with the corresponding old element and morph the old element\n                    unmatchedEls[curToNodeId] = curToNodeChild;\n                }\n            }\n\n            // If we got this far then we did not find a candidate match for our \"to node\"\n            // and we exhausted all of the children \"from\" nodes. Therefore, we will just\n            // append the current \"to node\" to the end\n            fromNode.appendChild(curToNodeChild);\n\n            curToNodeChild = toNextSibling;\n            curFromNodeChild = fromNextSibling;\n        }\n\n        // We have processed all of the \"to nodes\". If curFromNodeChild is non-null then\n        // we still have some from nodes left over that need to be removed\n        while(curFromNodeChild) {\n            fromNextSibling = curFromNodeChild.nextSibling;\n            removeNode(curFromNodeChild, fromNode, alreadyVisited);\n            curFromNodeChild = fromNextSibling;\n        }\n\n        var specialElHandler = specialElHandlers[fromNode.tagName];\n        if (specialElHandler) {\n            specialElHandler(fromNode, toNode);\n        }\n    }\n\n    var morphedNode = fromNode;\n    var morphedNodeType = morphedNode.nodeType;\n    var toNodeType = toNode.nodeType;\n\n    // Handle the case where we are given two DOM nodes that are not\n    // compatible (e.g. <div> --> <span> or <div> --> TEXT)\n    if (morphedNodeType === 1) {\n        if (toNodeType === 1) {\n            if (morphedNode.tagName !== toNode.tagName) {\n                onNodeDiscarded(fromNode);\n                morphedNode = moveChildren(morphedNode, document.createElement(toNode.tagName));\n            }\n        } else {\n            // Going from an element node to a text node\n            return toNode;\n        }\n    } else if (morphedNodeType === 3) { // Text node\n        if (toNodeType === 3) {\n            morphedNode.nodeValue = toNode.nodeValue;\n            return morphedNode;\n        } else {\n            onNodeDiscarded(fromNode);\n            // Text node to something else\n            return toNode;\n        }\n    }\n\n    morphEl(morphedNode, toNode, false);\n\n    // Fire the \"onNodeDiscarded\" event for any saved elements\n    // that never found a new home in the morphed DOM\n    for (var savedElId in savedEls) {\n        if (savedEls.hasOwnProperty(savedElId)) {\n            var savedEl = savedEls[savedElId];\n            onNodeDiscarded(savedEl);\n            walkDiscardedChildNodes(savedEl);\n        }\n    }\n\n    if (morphedNode !== fromNode && fromNode.parentNode) {\n        // If we had to swap out the from node with a new node because the old\n        // node was not compatible with the target node then we need to\n        // replace the old DOM node in the original DOM tree. This is only\n        // possible if the original DOM node was part of a DOM tree which\n        // we know is the case if it has a parent node.\n        fromNode.parentNode.replaceChild(morphedNode, fromNode);\n    }\n\n    return morphedNode;\n}\n\nmodule.exports = morphdom;"]}